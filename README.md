
####策略模式：
定义算法族，分别封装起来，让他们之间可以互相替换，让算法的变化独立于使用算法的客户

####观察者模式：
在对象间定义一对多的依赖，当一个对象改变状态，依赖它的对象都会收到通知。

####工厂模式：

####单例模式：
确保一个类只有一个实例，并提供全局访问

####命令模式：
将发出请求的对象和执行请求的对象解耦，两者间通过命令对象进行沟通，命令对象封装了接收者对象(执行请求对象)的一个或一组动作。
支持撤销操作。

####装饰者模式：
将一个对象包装起来以增加新的行为和责任（在原本基础上扩展功能）。

####适配器模式：
将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间（改变接口）。

####外观模式：
将一个或数个类的复杂的一切都隐藏在背后，只露出一个干净美好的外观（简化接口）。  
提供简化的接口的同时，依然将系统的完整功能暴露出来，以供需要的人使用。提供了一个统一的接口，用来访问子系统中的一群接口。定义了一个高层接口，让子系统更容易使用。

####模板方法模式：
提供了一个算法的步骤，并允许子类为一个或多个步骤提供实现。  
模板就是一个方法，方法中将算法定义一组步骤，其中的任何步骤都可以是抽象的，由子类负责实现。  
确保算法的结构保持不变，同时由子类提供部分实现。  
模板方法要用final声明，防止子类覆盖它。  
“钩子”能够作为条件控制，控制可选方法，影响抽象类中的算法流程。子类可以选择是否覆盖它。

####迭代器模式：
提供一种方法顺序访问一个聚合对象（ArrayList、数组等）中的各个元素，而又不暴露起内部的表示。
把访问任务放在迭代器上，而不是聚合上，简化了聚合的接口和实现。

####组合模式：
由菜单(个别对象)和菜单项(组合)组成一个树形结构，继承统一接口，在菜单和菜单项中重写不同方法，让客户可以以统一方式处理个别对象或组合。Page-364

####状态模式：
允许对象在内部状态改变时改变他的行为，对象看起来好像修改了他的类  
将状态封装成独立的类，并将动作委托到代表当前对象的状态，行为会随着内部状态改变而改变  
通过状态类中的动作(重写方法)来实现状态类的切换。  
  
类图和策略模式一样  
策略模式需要客户指定context所要组合的对象  
状态模式随着程序进行，当前状态在对象集合中切换改变，来改变context的状态，客户对状态对象不了解
